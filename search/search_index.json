{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Lind-WASM Project Documentation","text":"<p>Main Repo: https://github.com/Lind-Project/lind-wasm </p>"},{"location":"#what-is-lind-wasm-project","title":"What is Lind-WASM project?","text":"<p>We are building a secure and performant runtime system, which provides POSIX style system support for the WebAssembly (WASM) platform. Lind-WASM is compatible for unmodified C programs written for Linux, and can be executed as lightweight cages that enjoys Software Fault Isolation (SFI), fast Inter Process Communications (IPC), and many other advantages.</p> <p>The core components that we made contribution to are:</p> <ul> <li>WASM-glibc derived from glibc, the mot complete standard C library for the WASM platform</li> <li>Wasmtime runtime modified tos support Linux style memory management, threading, etc</li> <li>rustposix library OS that contributes to SFI and fast IPC</li> </ul>"},{"location":"buildGlibcWASM/","title":"Building glibc to WASM","text":"<p>I'd recommend reading this doc in its entirety before trying to compile.</p>"},{"location":"buildGlibcWASM/#prerequisites","title":"Prerequisites","text":"<p>We need WASM compatible <code>clang</code> and <code>ar</code>, which can be built locally from <code>wasi-sdk</code> https://github.com/WebAssembly/wasi-sdk</p> <p>Also strongly recommend to install <code>wasm-objdump</code> from the <code>wabt</code> toolkit https://github.com/WebAssembly/wabt</p>"},{"location":"buildGlibcWASM/#configure","title":"Configure","text":"<p>Firstly we should write and run a config script like this in the glibc root directory</p> <pre><code>#!/bin/bash\nset -e\nBUILDDIR=build\nmkdir -p $BUILDDIR\ncd $BUILDDIR\n../configure --disable-werror --disable-hidden-plt --with-headers=/usr/i686-linux-gnu/include --prefix=/sysroot-coulson --host=i686-linux-gnu --build=i686-linux-gnu\\\n    CFLAGS=\" -O2 -g\" \\\n    CC=\"/wasi-sdk/build/wasi-sdk-22.0/bin/clang-18 --target=wasm32-unkown-wasi -v -Wno-int-conversion\"\n</code></pre> <p>You must replace <code>CC</code> to the path to your <code>clang</code>. If you define <code>BUILDDIR=build</code>, then the compiled WASM object files will appear under <code>glibc/build</code>. Be aware that you should make sure this build directory is empty before running config script, so you need to <code>rm -rf build</code> before recompiling it.</p> <p>A crutial job of the configure script is deciding which sysdeps directories to use according to the <code>host</code> and <code>build</code> string. We already changed the configure script in glibc root directory, and the lind add-on directories are already baked to be included.</p> <p>The configure flags we need:</p> <ul> <li><code>disable-werror</code>: we have countless warnings, so we ignore them for now</li> <li><code>disable-hidden-plt</code>: PLT bypassing optimization is causing ~50k errors, simply disable it for now</li> <li><code>with-headers</code>: glibc requires Linux kernel headers to be installed before config and compile, so set this flag to a built-in sysroot of 32bit, this doesn't seem to raise an issue for our WASM built</li> <li><code>prefix=</code>: this is the path of the generated sysroot when you use <code>make install</code>. But note that, the glibc's <code>make install</code> will NOT work at all for WASM, because WASM sysroot has differen structure convention, also requires an <code>llvm-ar</code> arhive. More details, see my script <code>gen_sysroot.sh</code>. However, we can still use <code>make install</code> just to generate the <code>.h</code> files of the sysroot</li> <li><code>host</code> &amp; <code>target</code>: we start off from the sysdeps direcotries of i686, so fixing these options</li> </ul> <p>The compiler flags we need:</p> <ul> <li><code>-O2 -g</code>: nah the glibc won't allow you to compile with <code>O0</code>, so we bear with this <code>O2</code> optimization during debugging. But sometimes you can change to <code>O1</code>.</li> <li><code>-Wno-int-conversion</code>: we disable int conversion warnings, cuz all 32bit types as WASM function arguments, are eventually i32 anyway</li> <li><code>--target=wasm32-unkown-wasi</code>: this tells the compiler we want to compile to WASM</li> </ul> <p>After config succeed, you will see these in the <code>build</code> directory,</p> <pre><code>Makefile  bits  config.h  config.log  config.make  config.status\n</code></pre>"},{"location":"buildGlibcWASM/#compiling-to-object-files","title":"Compiling to object files","text":"<p>In the build directory, usually we use <code>make --keep-going -j$(nproc)</code>. The first flag is to continue compiling after errors, we need this cuz there are too many errors now (mainly due to assembly about threading). The <code>-j</code> is important to speed it up, but also makes the compilation log interleaved. The compilation log is VERY IMPORTANT, which tells why a given c file failed to be compiled. So sometimes we don't want the <code>-j</code>. Also, we can copy the actual compiler command in the compile log. For such commands, if we want to compile a single C file, only the source file path need to be further specified. We can use this to test compiling a specific file.</p>"},{"location":"buildGlibcWASM/#generating-wasm-sysroot","title":"Generating WASM sysroot","text":"<p>This procedure is specified in the <code>gen_sysroot.sh</code> script in our glibc repo. It's main job is to generate a WASM sysroot structre like</p> <pre><code>sysroot/\n- include/\n  - wasm32-wasi/\n    - stdio.h\n    - ...other headers\n- lib/\n  - wasm32-wasi/\n    - crt1.o\n    - libc.a\n</code></pre> <p>Note that the header files should be pre-generated using <code>make install</code>. The crt1.o should be pre-compiled from this simple C file (see the WASM compile doc as well). The main job of this script is find every valid WASM <code>.o</code> file in the <code>build</code> directory, and group everything into <code>libc.a</code>, an <code>llvm-ar</code> arvhive.</p> <pre><code>void _start() {\n    main();\n}\nvoid __wasm_call_dtors() {}\nvoid __wasi_proc_exit(unsigned int exit_code) {}\n</code></pre> <p>Here are some macros we need to twist:</p> <ul> <li><code>src_dir</code>: the glibc <code>build</code> directory that contains all the WASM object files</li> <li><code>include_source_dir</code>: the path to your pre-built headers</li> <li><code>crt1_source_path</code>: path to your pre-built crt1.o</li> <li><code>lind_syscall_path</code>: you also need to pre-compile <code>lind_syscall.o</code>, just like <code>crt1.o</code>, and the source file is under glibc/lind_syscall</li> <li><code>sysroot_dir</code>: path to generate the sysroot at</li> <li><code>output_archive</code>: the path to the generate the libc.a, should be align with <code>sysroot_dir</code></li> </ul>"},{"location":"buildGlibcWASM/#running-only-the-pre-processor","title":"Running only the pre-processor","text":"<p>The pre-processing stage of the compiler expland all <code>#include</code> and all macros. Because recursive macros are so prevalent in glibc, sometimes you want to see the actual source file after epxansions, then you want to use the <code>-E</code> option of <code>clang</code>.</p> <p>The easiest way is to copy the compiler command from the compile log and add a <code>-E</code>. If you want to run pre-prosessor on ALL files, then run the configure script again, but before compiling, add <code>-E</code> to <code>config.make</code> right after</p> <pre><code># Build tools.\nCC = /wasi-sdk/build/wasi-sdk-22.0/bin/clang-18 [ADD HERE!]\n</code></pre>"},{"location":"daily/","title":"Daily Progress Log","text":""},{"location":"daily/#wed-6192024","title":"Wed 6/19/2024","text":"<p>Summary: So today we implemented <code>brk</code>/<code>sbrk</code> in glibc (userspace), by over allocating to page-aligned address and exposing a \u201cpsudo-break\u201d to the caller. Now malloc is fully functional for small chunks that uses sbrk!</p> <p>When larger chunks are requested, the mmap path of malloc is triggerred. <code>mmap</code> is not yet handled.</p> <p>A side note is that, later we should bring <code>brk</code>/<code>sbrk</code> to the runtime space as syscalls, and add a mutex to the \u201cpsudo-break\u201d, otherwise race conditions are still possible under current implementation.</p>"},{"location":"daily/#mon-tue-617-182024","title":"Mon-Tue 6/17-18/2024","text":"<p>Looking at how are LinearMemory instances provisioned by the runtime, will include these in a seperate document.</p> <p></p> <p>In Wasmtime, the WASM module\u2019s linear memory is implemented by <code>MmapMemory</code> struct, which is a simple struct contains a <code>mmap</code> struct and a mutable <code>length</code>. The compiler (i.e. interpreter) do bounds checking according to the <code>length</code> field, so any address above <code>length</code> would be invalid. The <code>mmap</code> struct is implemented differently for different host OS. For linux, it\u2019s just the mmap provided by rustix  library. Note that they almost never use a \u201cfile\u201d for mmap, here mmap is just used to allocate memory.</p>"},{"location":"daily/#fri-6142024","title":"Fri 6/14/2024","text":"<p>Summary: Transitioned from Wasmer to Wasmtime, and added userspace debugging document. Also fixed the syscall return value at the interface between glibc and runtime.</p> <p>What's next: Find someway to implement <code>brk</code>/<code>sbrk</code> in the runtime as host functions.</p> <p>About host functions: Currently the <code>lind_syscall</code> host function is integrated within the <code>wasi_snapshot_preview1</code> interface, along with the <code>fd_write</code> stuff. I added this to preview1 for simplicity, where only the <code>from_witx!</code> and the witx file need to be changed. In the longer term we want to seperate lind_syscall with other wasi host functions of course.</p> <p>About function return of host functions: In wasi-libc and Wasmtime (also Wasmer), the host functions doesn't return the values to the userspace caller directly.  The last argument in the import signature (e.g. <code>__imported_wasi_snapshot_preview1_fd_write</code> in <code>wasi-libc</code>) is actually a pointer to the return value. When I implemented <code>lind_syscall</code> host function, the last argument in the import signature is also an <code>unsigned int</code>, where in the userspace I firstly decalre <code>int ret = 0</code>, then pass <code>&amp;(unsigned int) ret</code> as the last argument. And copying the value returned by the actual <code>lind_syscall</code> in Wasmtime to the <code>ret</code> happens implicitly.</p>"},{"location":"daily/#wed-6122024","title":"Wed 6/12/2024","text":"<p>Summary: Consecutive syscalls okay in Wasmer (lind init in <code>run_wasm</code>). Added complete syscall support for malloc, except <code>brk</code>/<code>sbrk</code>.</p> <p>Issues: 1) malloc fails after several mmap/munmap calls, hard to debug 2) the <code>brk</code> syscall needs special handling, where <code>wasi-libc</code> is implemented with the compiler emitted function <code>__builtin_wasm_memory_grow</code>. Note that currently lind's <code>brk</code> is managed by NaCl.</p> <p>What's next: We MUST find a way to trace/debug the wasm runtime's user space. We are currently exploring both Wasmer and Wasmtime's potential to do this. The <code>brk</code> need more investigation.</p> <p>Wasmer has a \"DWARF debugging repo here https://github.com/wasmerio/wasm-debug. [Well okay, this is way too obsolete]</p> <p>Wasmtime's doc on debugging https://github.com/bytecodealliance/wasmtime/blob/main/docs/examples-debugging-native-debugger.md</p> <p>trying to understand both</p>"},{"location":"daily/#tue-6112024","title":"Tue 6/11/2024","text":"<p>Summary: <code>malloc-hello</code> compiles successfully, Wasmer also validate the module successfully.</p> <p>What's next: the program fails after the first syscall to lind, as the initial modifications to Wasmer doesn't support consecutive syscalls. I'll update Wasmer to support consecutive syscalls, and Dennis will adapt more syscalls in glibc / rustposix.</p> <p>Adapted <code>writev</code> and <code>munmap</code> in glibc to use lind syscalls. Add rustposix new dispatcher support for these 2 calls.</p> <p>When we removed assembly implementations earlier, we added dummy replacement functions with argument types of <code>uint64_t</code>, which was absolutely wrong. We should just use standard posix arguments here, and the type conversion to <code>i64</code> is done by our <code>MAKE_SYSCALL</code> macro.</p> <p>Added the WASM program compilation doc.</p>"},{"location":"daily/#starting-this-doc-today","title":"Starting this Doc Today!","text":"<p>--- BELOW WILL BE JUST SLACK MESSAGE HISTORIES :) ---</p>"},{"location":"daily/#mon-6102024","title":"Mon 6/10/2024","text":"<p>Coulson:</p> <p>As a first step to resolve the glibc\u2019s internal use of TLS <code>initial-exec</code> model, I just made two changes - I replaced the TLS variable attributes and root-level makefile to use <code>local-exec</code>, which is supported by WASM compiler - In glibc/locale directory, many files use the national locale <code>NL_CURRENT_DEFINE</code> macro, which contains some assembly doing value assignment and variable visibility setting. The use of assembly here is completely unnecessary, so I replaced the macro definition with plain C, with the same effect. See this commit</p> <p>After these changes, the <code>_nl_current_LC_CTYPE_used</code> issue I posted in this channel on June 2nd, is resolved.</p>"},{"location":"daily/#fri-sat-67-82024","title":"Fri-Sat 6/7-8/2024","text":"<p>Coulson:</p> <p>So I carefully reviewed <code>native_client</code>\u2019s TLS related code, and compared normal glibc\u2019s i386 tls.h file with <code>nacl-glibc</code>\u2019s i386.h file (note that both nacl and ours are actually using i386 in glibc). Here\u2019s the conclusion: NaCl doesn\u2019t manage TLS variables at all, both <code>NaClSysTlsInit</code> and <code>NaClSysTlsGet</code> are actually used to get the pointer to the TLS_base. Like I reported yesterday, x86 uses the <code>gs</code>/<code>fs</code> register to store the pointer to the TLS_base. Because NaCl is cross platform, and this <code>gs</code> register doesn\u2019t exist on some arch, NaCl just use these two syscalls to mimic this register.</p>"},{"location":"daily/#thu-662024","title":"Thu 6/6/2024","text":"<p>Added the TLS doc.</p> <p>Coulson:</p> <p>So I wrote a note. Now I know how the compiler and linker handles TLS even without threading, they expose 2 constants, 1 mut var, and 1 function to the threading library. Also understood how is <code>wasi-libc</code> pthread library built on-top-of these. Although I wrote this doc with wasm environment as examples, the general mechanisms are the same for normal linux.</p>"},{"location":"daily/#wed-652024","title":"Wed 6/5/2024","text":"<p> Coulson:</p> <p>An super important distinction between TLS and the threading library\u2019s TSD need our attention</p> <ul> <li>TLS: provided by the compiler and linker, exists even without pthread library at all.</li> <li>TSD: (thread specific data): this is the interface provisioned by the pthread  library, which is implemented by nptl  (also wasi-libc  threading built). This includes the getspecific()  and setspecific()  functions. In both glibc \u2019s nptl  and the wasi-libc  case, these are build on-top-of TLS</li> </ul>"},{"location":"daily/#sat-612024","title":"Sat, 6/1/2024","text":"<p>First time seeing the series of errors related to <code>initial-exec</code> absolute addressing</p> <pre><code>wasm-ld: error: /glibc/sysroot/lib/wasm32-wasi/libc.a(wcsmbsload.o): undefined symbol: _nl_current_LC_CTYPE\n</code></pre>"},{"location":"daily/#wed-5292024","title":"Wed, 5/29/2024","text":"<p>Coulson:</p> <p>A sidenote here, when we use clang  with WebAssembly target, if we are building a library, we need the -c  flag. Without -c , we are building an executable whose functions will not be shared.</p> <p>Also some exiting updates here</p> <ul> <li>Now using our wasm glibc\u2019s sysroot to compile a simple hello world, the secondary compilation in Wasmer is also passed! The only thing left is to refine the Wasmer\u2019s host function interface connecting to rustposix, which is easy.</li> <li>I implemented the WASM syscall interface inside glibc, as a separate directory at /glibc/lind_syscall</li> <li>I implemented a shell script that can generate a WASM sysroot from the glibc\u2019s building directory by one command</li> </ul> <p>Dennis:</p> <p>Some updates from my side, I have implemented write, read, close, access and open syscalls to be used for \"hello world\" example from Coulson side.</p> <p>Coulson:</p> <p>We can run a write-syscall-only hello world succesfully, from our WASM glibc, to the generic lind syscall interface added in Wasmer, to the new 3i-style layer newly implemented by Dennis in rustposix!</p>"},{"location":"daily/#mon-tue-627-282024","title":"Mon-Tue, 6/27-28/2024","text":"<p>Sepnt some time on debugging the</p> <pre><code>error: Unable to compile \"newhello.wasm\"\n\u2570\u2500\u25b6 1: Validation error: type mismatch: values remaining on stack at end of block (at offset 0x26a)\n</code></pre> <p>The way to solve similar issues was added to the WASM compile doc.</p>"},{"location":"daily/#fri-5242024","title":"Fri, 5/24/2024","text":"<p>Start to add</p> <ul> <li>wasmer should pass linear mem start addr to rustposix</li> <li>rustposix should have the 3i style layer that do the address translation</li> </ul>"},{"location":"daily/#thu-5232024","title":"Thu, 5/23/2024","text":"<p>Coulson:</p> <p>Now we further cleared the errors, now it\u2019s 1827 errors, and Zero Segfaults.</p> <p>The <code>SINGLE_THREAD_P</code> issue were due to mismatch of .c and other stuff, because we deleted the asm, the malloc fall down to the generic implementation, while the header file actually included is still the sysdep one. After deleting the sysdep header to force using generic header file, many errors were resolved</p> <p>As a result, now we also have the full malloc library!</p>"},{"location":"daily/#wed-5222024","title":"Wed, 5/22/2024","text":"<p>Coulson:</p> <p>(Disable PLT bypassing) Well now we are constantly shrinking the set of errors and gets more .o files. This morning we have 65000 errors, but now it\u2019s 4500.</p>"},{"location":"daily/#mon-5202024","title":"Mon, 5/20/2024","text":"<p>Coulson:</p> <p>So, now the entire string library is complete, after further clean-up asm stuff. And the 4000 seg faults, now only 139 remains.</p> <p>Note that we are now cleaning the asm not in the sysdeps directories!</p> <p>But note that there are still countless compilation errors out there. This also makes sense because if we compare this wasm32 built with a normal complete built, we can see that any fancy stuff (like single-instruction-multiple-data) just failed (or disabled) during the process as expected, but this doesn\u2019t bother we get the rest done. So these are okay errors</p>"},{"location":"daily/#fri-sun-517-192024","title":"Fri-Sun, 5/17-19/2024","text":"<p>So dennis today fixed a handful clang segfault occurrences by trial-and-error on various includes, in a case-by-case manner. For example, <code>csu/check_fds.c</code> gets <code>#include &lt;not-cancel.h&gt;</code> removed, then it compiles</p> <p>and <code>csu/init_first.c</code> gets sysdep.h libc-internal.h ldsodefs.h  removed, then it compiles But I saw that there are still 3903 such seg fault, throughout the compilation process, not just the csu part, so handling each of them one by one is not plausible, and I was doing some DFS on this issue, hoping we can get to know, what specifically is causing the clang segfault.</p> <p>I spent a few hours trying to track down the issue, and I doubt it\u2019s still because some assembly code out there. Here\u2019s the reason. Initially, compiling csu/check_fds.c  would cause the segfault, where <code>csu/check_fds.c</code> includes <code>sysdeps/unix/sysv/linux/not-cancel.h</code> which includes the sysdep.h implemented at sysdeps/unix/i386/sysdep.h , which contains bunch of assembly macros, and further includes other sysdep.h files contains assembly macros.</p> <p>Then, if we clear this sysdeps/unix/i386/sysdep.h , the segfault for csu/check_fds.c goes away.</p> <p>The problem is that, for the next file <code>csu/init_first.c</code> causing segfault, removing the sysdep.h includes is needed but not enough. We definitely need to explore this more, there\u2019s still a lot of confusions. These are the hints we have so far.</p> <p>Ah Ha!</p> <p>Okay, I know what\u2019s the clang bug here. There are some occurrences of using inline asm to do symbol aliasing, like, <code>__asm__ (\"mempcpy = __GI_mempcpy\");</code></p> <p>when the clang compiler set with wasm target sees this, it won\u2019t raise any error but simply get a segmentation fault</p> <p>If I put this one line into a c file, then trying to compile it simply trigger exactly the same seg fault we see through out the compilation process </p> <p>Then people will ask, why I and Dennis missed these inline asm? :joy: (edited) </p> <p>Because they are not in the sysdeps directly, but in the glibc/include directory. Because stuff like symbol aliasing are not arch specific though it is indeed assembly, and when I firstly started the sanitization I supposed all assembly are arch specific. I only realized this after hours and hours of inspection.</p> <p>Now we will sanitize the glibc/include, then I think we can have a leap on the compilation.</p>"},{"location":"daily/#tue-5142024","title":"Tue, 5/14/2024","text":"<p>Dennis:</p> <p>At this stage, we have removed the in-line asm in glibc as well. But when compiling with wasm32, we encountered error: clang frontend command failed with exit code 139 (use -v to see invocation and it seems like we triggered a bug in llvm.</p> <p>Coulson:</p> <p>Start using <code>--keep-going</code> to skip the seg faults. Also tested that the individual wasm object files are indeed usable.</p>"},{"location":"daily/#tue-4302024","title":"Tue, 4/30/2024","text":"<p>Justin:</p> <p>I've thought some more and think the macro call in glibc should look like this (I don't care what you name the macro): <code>MAKE_SYSCALL(syscallnum,\"syscall|callname\", arg1, arg2, arg3, arg4, arg5, arg6)</code></p> <p>with write looking like: <code>MAKE_SYSCALL(2,\"syscall|write\", (uint64)fd, (uint64)buf, (uint64)len, NOTUSED, NOTUSED, NOTUSED)</code> NOTUSED should be defined to be a magic value that will be obviously not a normal value (avoiding NULL, 0, 1, etc.) if it shows up in a debugger / output, it is not confused for a user passed value.  Something like 0xdeadbeefdeadbeef. My rationale for having this slightly more complex macro is that later on if we decide we want to switch to keying them based upon strings instead of numbers, this will be much easier.  It also isn't any different from an efficiency standpoint, since the preprocessor will just strip out the string if we don't use it.</p>"},{"location":"daily/#thu-4252024","title":"Thu, 4/25/2024","text":"<p>Coulson:</p> <p>The fundamental way that wasi-libc  implements a syscall and declare that symbol for compiler/runtime is clear to me now, basically the the <code>__import_module__</code> and <code>__import_name__</code> are the magical symbols that has NO DEFINITION. So these should be the <code>wasi-libc</code>\u2019s secrete signals to tell the WASM compiler and runtime what external symbol it needs.</p> <p></p> <p>Dennis:</p> <p>Note that the import namespace and function name should be align with the how the runtime exports them. e.g. how Wasmer exports <code>wasi_smapshot_preview1</code></p>"},{"location":"daily/#the-wild-age","title":"The Wild Age","text":"<p>This project started in March, 2024.</p> <p>Earlier history won't be helpful, these days we were doing the intial experiments on the WASM runtime and libcs.</p> <p>We also don't have a very orgnized record of our removal of assembly code in glibc, unfortunately.</p>"},{"location":"team/","title":"Lind-WASM Team at NYU Secure Systems Lab","text":""},{"location":"understandTls/","title":"Understanding TLS","text":"<p>The most important take away of this document is to know the compiler/linker emitted symbols: constants <code>__tls_size</code> and <code>__tls_align</code>, mut variable <code>__tls_base</code>, and the function <code>__wasm_init_tls</code>.</p>"},{"location":"understandTls/#general-tls-supports-of-the-compiler-and-linker-without-the-presence-of-a-threading-library","title":"General TLS supports of the compiler and linker without the presence of a threading library","text":"<p>Compiler:</p> <ul> <li>recognizes the variables declared with TLS qualifier (<code>__thread</code> or <code>_Thread_local</code>, different qualifiers depends on the compiler)</li> <li>put TLS variables into special segments of the object file, <code>tdata</code> for initialized variables, and <code>tbss</code> for uninitialized ones</li> <li>generate code for accessing each TLS variable with the address calculated by adding an offset to the <code>TLS_base</code>. Note that this   <code>TLS_base</code> is a mutable, latter I'll mention how to set this value. <code>TLS_base</code> is a thread-specific pointer points to the starting address of the TLS block for that thread. The actual place storing this <code>TLS_base</code> pointer varries depends on the compiler and architecture (e.g., for x86_64, GCC put this pointer at the <code>fs</code> register, and for WASM, this can be accessed by <code>global.set</code> and <code>global.get</code>).</li> </ul> <p>Linker:</p> <ul> <li>consolidates the TLS segments from different objet files into a single one, which need to recalculate the offsets of each TLS variable</li> <li>the linker also create symbols <code>TLS_size</code>, <code>TLS_align</code>, and a TLS init function. In the case of WASM these are <code>__tls_size</code>, <code>__tls_align</code>, <code>__tls_base</code>, and the function <code>__wasm_init_tls(mem)</code>, where the <code>mem</code> parameter is a pointer specifying the location to init the TLS block.</li> </ul> <p>Threading library (wasm):</p> <p>Note that the <code>__wasm_init_tls</code> simply initialize the TLS block according to the TLS variables declared in the source file, it doesn't allocate the memory. So, when <code>wasi-libc</code> implements the threading library, it uses the const symbols <code>__tls_size</code> and <code>__tls_align</code> to pre-allocate the TLS memory before invoking <code>__wasm_init_tls</code>. And of course, like we anticipated, the <code>pthread_create</code> calls <code>__wasm_init_tls</code> to set up the new thread's TLS block. Eventually the <code>pthread_create</code> also set the <code>__tls_base</code> variable, so that later the user's code will access the TLS variables starting from this base address.</p> <p>For more detailed description of <code>__tls_size</code> and <code>__tls_align</code>, see this LLVM doc https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md#thread-local-storage.</p>"},{"location":"wasmCompile/","title":"Troubleshooting Compiling WASM","text":"<p>Assuming using <code>clang-18</code> provided by the <code>wasi-sdk-22.0</code>.</p>"},{"location":"wasmCompile/#frequently-used-flags","title":"Frequently Used Flags","text":"<ul> <li><code>--target=wasm32-unkown-wasi</code> for compiling to wasm</li> <li><code>-c</code> for compiling as a library without main executable</li> <li><code>-pthread</code> then the compiler to understand <code>__tls_base</code> etc</li> <li><code>--sysroot</code> specifying the stand library path</li> </ul>"},{"location":"wasmCompile/#inspecting-an-object-file","title":"Inspecting an Object File","text":"<p>Use <code>wasm-objdump -x</code> to show all functions, globals, etc included in the object file. Use <code>-d</code> to disassemble and see text instructions.</p>"},{"location":"wasmCompile/#locating-type-mismatch-error","title":"Locating Type Mismatch Error","text":"<p>Even successfully compile a source into .wasm, a typical error due to mismatch will manifest during secondary compilation, like this</p> <pre><code>root@2299d4e20d1f:/lind-glibc/replace-sysroot/test# /wasmer/target/debug/wasmer run newhello.wasm\nerror: Unable to compile \"newhello.wasm\"\n\u2570\u2500\u25b6 1: Validation error: type mismatch: values remaining on stack at end of block (at offset 0x26a)\n</code></pre> <p>One can also verify and get the same error by <code>wasm2wat</code>, which gives a more detailed message. To debug, we can use <code>wasm-objdump -x</code> to see the function types, a typical output is this</p> <pre><code>Section Details:\n\nType[16]:\n - type[0] (i32, i32) -&gt; i32\n - type[1] (i32) -&gt; nil\n - type[2] (i32, i32, i32, i32, i32, i32, i32, i32) -&gt; i32\n - type[3] (i32, i64, i64, i64, i64, i64, i64, i64) -&gt; i32\n - type[4] () -&gt; nil\n - type[5] () -&gt; i32\n - type[6] (i32, i32, i32) -&gt; i32\n - type[7] (i32) -&gt; i32\n - type[8] (i32, i32, i32, i64) -&gt; i32\n - type[9] (i32, i32, i32) -&gt; nil\n - type[10] (i32, i32, i32, i32) -&gt; i32\n......\nImport[1]:\n - func[0] sig=3 &lt;__imported_wasi_snapshot_preview1_lind_syscall&gt; &lt;- wasi_snapshot_preview1.lind_syscall\nFunction[92]:\n - func[1] sig=4 &lt;_start&gt;\n - func[2] sig=4 &lt;__wasm_call_dtors&gt;\n - func[3] sig=5 &lt;__original_main&gt;\n - func[4] sig=6 &lt;__libc_write&gt;\n - func[5] sig=7 &lt;__brk&gt;\n - func[6] sig=7 &lt;__sbrk&gt;\n - func[7] sig=0 &lt;__clock_gettime64&gt;\n - func[8] sig=0 &lt;__GI___munmap&gt;\n - func[9] sig=6 &lt;__GI___madvise&gt;\n - func[10] sig=6 &lt;__open64_nocancel&gt;\n......\n</code></pre> <p>Note that the <code>Type</code> section defines all the function args/ret types, and for each function, the <code>sig=X</code> just means the function has <code>type[X]</code>.</p>"},{"location":"wasmtime-debug/","title":"Introduction to Wasmtime and Debugging with GDB","text":""},{"location":"wasmtime-debug/#what-is-wasmtime","title":"What is Wasmtime?","text":"<p>Wasmtime is a standalone JIT-style runtime for WebAssembly, designed for use with WebAssembly System Interface (WASI) and other WASI-inspired environments. It is part of the Bytecode Alliance, an open-source effort to create secure software foundations.</p> <p>Wasmtime can run WebAssembly modules that follow the WASI standard, providing a robust and efficient environment for running WebAssembly outside of the browser.</p>"},{"location":"wasmtime-debug/#getting-started-with-wasmtime","title":"Getting Started with Wasmtime","text":"<p>To get started with Wasmtime, you can download and install it from the official Wasmtime releases page. Follow the installation instructions specific to your operating system.</p>"},{"location":"wasmtime-debug/#compiling-a-webassembly-module-with-clang","title":"Compiling a WebAssembly Module with Clang","text":"<p>Let's start with a simple example, <code>malloc-test.c</code>, which demonstrates dynamic memory allocation using <code>malloc</code> in C. We will compile this C program to a WebAssembly module using Clang with the WASI target.</p>"},{"location":"wasmtime-debug/#example-c-program-malloc-testc","title":"Example C Program: <code>malloc-test.c</code>","text":"<pre><code>#include &lt;unistd.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    const char *str = \"Hello from Dennis's WASM!\\n\";\n\n    size_t str_len = strlen(str) + 1;\n\n    char *buf = malloc(str_len);\n\n    if (buf == NULL) {\n        return -1;\n    }\n\n    strcpy(buf, str);\n\n    write(1, buf, str_len - 1);\n\n    free(buf);\n\n    return 0;\n}\n</code></pre>"},{"location":"wasmtime-debug/#compiling-the-program","title":"Compiling the Program","text":"<p>Use the following command to compile the <code>malloc-test.c</code> program to WebAssembly:</p> <pre><code>../../clang+llvm-16.0.4-x86_64-linux-gnu-ubuntu-22.04/bin/clang-16 --target=wasm32-unknown-wasi --sysroot /home/dennis/Documents/Just-One-Turtle/wasi-libc/sysroot malloc-test.c -g -O0 -o malloc-test.wasm\n</code></pre> <ul> <li><code>--target=wasm32-unknown-wasi</code>: Specifies the target to be WebAssembly with WASI.</li> <li><code>--sysroot /home/dennis/Documents/Just-One-Turtle/wasi-libc/sysroot</code>: Points to the WASI sysroot directory.</li> <li><code>-g</code>: Includes debugging information.</li> <li><code>-O0</code>: Disables optimizations for easier debugging.</li> </ul>"},{"location":"wasmtime-debug/#running-the-webassembly-module-with-wasmtime","title":"Running the WebAssembly Module with Wasmtime","text":"<p>After compiling the WebAssembly module, you can run it using Wasmtime:</p> <pre><code>../wasmtime/target/debug/wasmtime run malloc-test.wasm\n</code></pre>"},{"location":"wasmtime-debug/#debugging-with-gdb","title":"Debugging with GDB","text":"<p>To debug the WebAssembly module, you can use GDB with Wasmtime. Ensure that you have compiled the module with the <code>-g</code> flag to include debugging information.</p> <p>NOTE: currently this debugging tool does not support inspecting instructions. And operations like <code>layout split</code> and <code>si</code> might break the terminal. Using <code>layout src</code> is recommended.</p>"},{"location":"wasmtime-debug/#running-gdb-with-wasmtime","title":"Running GDB with Wasmtime","text":"<p>Use the following command to run GDB with Wasmtime:</p> <pre><code>gdb --args ../wasmtime/target/debug/wasmtime run -D debug-info -O opt-level=0 malloc-test.wasm\n</code></pre> <ul> <li><code>gdb --args</code>: Passes the arguments to GDB.</li> <li><code>../wasmtime/target/debug/wasmtime run</code>: Specifies the Wasmtime executable.</li> <li><code>-D debug-info</code>: Enables debugging information.</li> <li><code>-O opt-level=0</code>: Sets the optimization level to 0 for debugging.</li> </ul>"},{"location":"wasmtime-debug/#example-debugging-session","title":"Example Debugging Session","text":"<ol> <li> <p>Start GDB:    <code>sh    gdb --args ../wasmtime/target/debug/wasmtime run -D debug-info -O opt-level=0 malloc-test.wasm</code></p> </li> <li> <p>Set Breakpoints:    In the GDB prompt, set breakpoints as needed, for example:    <code>sh    (gdb) break main</code></p> </li> <li> <p>Run the Program:    Start the execution of the WebAssembly module:    <code>sh    (gdb) run</code></p> </li> <li> <p>Inspect and Debug:    Use GDB commands to inspect variables, step through the code, and debug your program:    <code>sh    (gdb) next    (gdb) print p    (gdb) continue</code></p> </li> </ol> <p>By following these steps, you can compile, run, and debug WebAssembly modules using Wasmtime and GDB. This provides a powerful environment for developing and debugging WebAssembly applications.</p> <p>For more details, refer to the official Wasmtime documentation and the GDB documentation.</p>"},{"location":"writeDoc/","title":"How to Add Documentation","text":"<p>This doc is using the <code>material</code> for <code>mkdocs</code>, which turns markdown files into an online doc website.</p> <p>You should have <code>mkdocs</code> installed on your terminal first.</p> <p>To add a new seperate page of documentation, you need to</p> <ol> <li>add a new <code>.md</code> markdown file to the <code>docs/</code> directory</li> <li>in the <code>mkdocs.yml</code> file's <code>nav:</code> section, add a the new page's path</li> <li>IMPORTANT: test if the changes works as expected by running <code>mkdocs serve</code> in the root directory of this repo, only push the changes after checking it works</li> </ol> <p>NOTE: a github action of compiling these markdown files has already been setup. Once the changes of <code>.md</code> files are pushed, the static website branch will be automatically updated shortly.</p>"}]}